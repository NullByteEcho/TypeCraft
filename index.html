<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeCraft - Practice Touch Typing With Your Documents</title>
    <!-- PDF.js libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js"></script>
    <!-- Mammoth.js for DOCX support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #a855f7;
            --light: #f8fafc;
            --dark: #1e293b;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --border-radius: 8px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--light);
            color: var(--dark);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .logo-icon {
            font-size: 28px;
            margin-right: 10px;
        }
        
        h1 {
            font-size: 2.5rem;
            color: var(--primary-dark);
        }
        
        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: var(--primary-dark);
        }
        
        p {
            margin-bottom: 15px;
        }
        
        .card {
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 25px;
        }
        
        .upload-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed #cbd5e1;
            border-radius: var(--border-radius);
            padding: 40px 20px;
            margin-bottom: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-section:hover {
            border-color: var(--primary);
            background-color: rgba(99, 102, 241, 0.05);
        }
        
        .upload-icon {
            font-size: 48px;
            color: var(--primary);
            margin-bottom: 15px;
        }
        
        .btn {
            padding: 12px 24px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 10px 0;
        }
        
        .btn:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: #94a3b8;
        }

        .btn-secondary:hover {
            background-color: #64748b;
        }
        
        .file-input {
            display: none;
        }
        
        /* Typing view styles */
        .typing-view {
            display: none;
        }
        
        .nav-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .nav-title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .nav-controls {
            display: flex;
            gap: 10px;
        }
        
        .document-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 120px);
            overflow: hidden;
            margin-top: 20px;
            position: relative;
        }
        
        .document-view {
            flex-grow: 1;
            overflow-y: auto;
            padding: 25px;
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
            position: relative;
        }
        
        .document-viewport {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }
        
        /* Pagination controls */
        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background-color: white;
            border-top: 1px solid #e2e8f0;
        }

        .pagination-controls button {
            margin: 0 5px;
            padding: 8px 16px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .pagination-controls button:disabled {
            background-color: #cbd5e1;
            cursor: not-allowed;
        }

        .pagination-info {
            margin: 0 15px;
            font-size: 14px;
        }
        
        /* Typing progress bar */
        .typing-progress-bar {
            position: sticky;
            bottom: 0;
            padding: 15px;
            background-color: white;
            border-top: 1px solid #e2e8f0;
            border-radius: 0 0 var(--border-radius) var(--border-radius);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            z-index: 50;
        }
        
        .typing-progress-item {
            display: flex;
            align-items: center;
            font-size: 14px;
            color: #64748b;
        }
        
        .typing-progress-value {
            font-weight: 600;
            color: var(--dark);
            margin-left: 5px;
        }
        
        /* Character highlighting styles */
        .text-char {
            display: inline-block;
            position: relative;
            letter-spacing: normal;
            padding: 0 1px;
            user-select: none; /* Prevent text selection */
        }
        
        .text-char.current {
            background-color: rgba(99, 102, 241, 0.3);
            border-radius: 2px;
            padding: 0 1px;
        }
        
        .text-char.correct {
            color: var(--success);
        }
        
        .text-char.incorrect {
            color: var(--error);
            text-decoration: underline wavy var(--error);
        }
        
        .typing-cursor {
            position: absolute;
            display: inline-block;
            width: 2px;
            height: 18px;
            background-color: var(--primary);
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        
        /* Document formats */
        .document-text {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 50px;
            min-height: 1100px; /* A4 size approximately */
            position: relative;
            font-size: 16px;
            line-height: 1.6;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        /* Improved text styles for better readability */
        .document-text p {
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 20px;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #1e293b;
            letter-spacing: 0.01em;
        }

        /* Document page styles */
        .document-page {
            display: none;
            margin-bottom: 30px;
        }

        .document-page.active {
            display: block;
        }
        
        /* Completion modal */
        .completion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: white;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 500px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        
        .stats-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 25px 0;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            font-size: 36px;
            font-weight: bold;
            color: var(--primary-dark);
        }
        
        .stat-label {
            font-size: 14px;
            color: #64748b;
        }
        
        /* Loading indicator */
        .loading-indicator {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #e2e8f0;
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Typeable wrapper - making the document directly typeable */
        .typeable-wrapper {
            position: relative;
            outline: none;
        }
        
        .typeable-wrapper.current {
            background-color: rgba(99, 102, 241, 0.05);
            border-radius: 4px;
            padding: 2px;
        }
        
        .typeable-wrapper.completed {
            background-color: rgba(16, 185, 129, 0.05);
        }

        /* Save indicator */
        .save-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .save-indicator.visible {
            opacity: 1;
        }
        
        /* Learning Article Styles */
        .learning-view {
            display: none;
            padding: 20px;
            background-color: var(--light);
        }
        
        .article-container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 40px;
        }
        
        .article-page {
            margin-bottom: 30px;
        }
        
        .article-container h1 {
            font-size: 2.2rem;
            margin-bottom: 20px;
            color: var(--primary-dark);
            text-align: center;
        }
        
        .article-container h2 {
            font-size: 1.8rem;
            margin: 35px 0 15px;
            color: var(--primary-dark);
            border-bottom: 2px solid rgba(99, 102, 241, 0.3);
            padding-bottom: 8px;
        }
        
        .article-container h3 {
            font-size: 1.4rem;
            margin: 25px 0 15px;
            color: var(--dark);
        }
        
        .article-container p {
            margin-bottom: 20px;
            line-height: 1.8;
            font-size: 18px;
        }
        
        .highlight-box {
            background-color: rgba(99, 102, 241, 0.1);
            border-left: 4px solid var(--primary);
            padding: 20px;
            margin: 25px 0;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }
        
        .article-container ul, .article-container ol {
            margin-bottom: 20px;
            padding-left: 25px;
        }
        
        .article-container li {
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .article-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .document-container {
                height: calc(100vh - 150px);
            }
            
            .nav-controls {
                flex-wrap: wrap;
            }
            
            .btn {
                padding: 8px 16px;
                font-size: 14px;
            }
            
            .document-view {
                padding: 15px;
            }
            
            .document-text {
                padding: 20px;
            }
            
            .article-container {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="welcomeScreen">
            <header>
                <div class="logo">
                    <span class="logo-icon">⌨️</span>
                    <h1>TypeCraft</h1>
                </div>
                <p>Upload your own documents and practice touch typing while reinforcing reading comprehension</p>
            </header>
            
            <main>
                <div class="card">
                    <h2>Get Started</h2>
                    <p>Upload a document to start practicing your typing skills. Compatible with PDF, Word (DOCX), HTML, TXT, and Markdown files.</p>
                    
                    <div class="upload-section" id="dropArea">
                        <div class="upload-icon">📄</div>
                        <p>Drag and drop your document here</p>
                        <p>or</p>
                        <button class="btn" id="uploadBtn">Choose a file</button>
                        <input type="file" id="fileInput" class="file-input" accept=".txt,.pdf,.docx,.doc,.html,.htm,.rtf,.md,.markdown">
                        <p class="info-text">Your documents are processed locally - nothing is stored on our servers</p>
                    </div>
                    
                    <div id="savedSessionsContainer" style="display: none;">
                        <h3>Continue where you left off</h3>
                        <div id="savedSessionsList"></div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button class="btn" id="learnMoreBtn">Learn How TypeCraft Enhances Learning</button>
                    </div>
                </div>
            </main>
        </div>
        
        <!-- Document Typing View -->
        <div id="typingView" class="typing-view">
            <div class="nav-bar">
                <div class="nav-title">
                    <span id="documentTitle">Document Name</span>
                </div>
                <div class="nav-controls">
                    <button class="btn btn-secondary" id="backToMainBtn">Back to Main</button>
                    <button class="btn" id="resetTypingBtn">Reset Progress</button>
                    <button class="btn" id="saveProgressBtn">Save Progress</button>
                </div>
            </div>
            
            <div class="document-container">
                <div class="document-view" id="documentView">
                    <div class="document-viewport" id="documentViewport">
                        <!-- Document content will be rendered here -->
                    </div>
                </div>
                
                <!-- Pagination controls -->
                <div class="pagination-controls" id="paginationControls">
                    <button id="prevPageBtn" disabled>Previous Page</button>
                    <div class="pagination-info">Page <span id="currentPage">1</span> of <span id="totalPages">1</span></div>
                    <button id="nextPageBtn">Next Page</button>
                    <button id="skipPageBtn">Skip Page</button>
                </div>
                
                <div class="typing-progress-bar">
                    <div class="typing-progress-item">
                        WPM: <span class="typing-progress-value" id="wpmValue">0</span>
                    </div>
                    <div class="typing-progress-item">
                        Accuracy: <span class="typing-progress-value" id="accuracyValue">0%</span>
                    </div>
                    <div class="typing-progress-item">
                        Progress: <span class="typing-progress-value" id="progressValue">0%</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Learning Article View -->
        <div id="learningView" class="learning-view">
            <div class="nav-bar" style="margin-bottom: 20px;">
                <div class="nav-title">
                    <span>TypeCraft Learning Guide</span>
                </div>
                <div class="nav-controls">
                    <button class="btn btn-secondary" id="backFromArticleBtn">Back to Main</button>
                </div>
            </div>
            
            <div class="article-container">
                <div class="article-page">
                    <h1>Learning Through Typing: How TypeCraft Enhances Knowledge Retention</h1>
                    
                    <h2>The Science Behind Active Learning</h2>
                    <p>When we read passively, our brains often go into "cruise control" mode, which can limit how much information we truly absorb and retain. TypeCraft transforms this passive experience into an active one by engaging your motor skills alongside your cognitive processes. This multi-sensory approach creates stronger neural pathways and enhances memory formation.</p>
                    
                    <p>Research in cognitive psychology has consistently shown that active engagement with material leads to better learning outcomes than passive consumption. By physically typing each character of your study material, you:</p>
                    <ul>
                        <li>Slow down your reading pace to a more deliberate level</li>
                        <li>Process information through multiple channels (visual, tactile, cognitive)</li>
                        <li>Create additional memory cues through physical movement</li>
                        <li>Force yourself to pay attention to every word, reducing mind-wandering</li>
                    </ul>
                    
                    <h2>Effective Learning Strategies with TypeCraft</h2>
                    
                    <h3>1. The Focused First Pass</h3>
                    <p>For your initial engagement with complex material, use TypeCraft to complete a "focused first pass." This technique involves typing through the material with full attention, deliberately slowing your consumption rate to match your typing speed. This enforced pacing helps prevent the common mistake of rushing through difficult concepts before they're fully understood.</p>
                    
                    <h3>2. Selective Emphasis</h3>
                    <p>When reviewing material you've previously studied, use TypeCraft strategically:</p>
                    <ul>
                        <li>Type only the key paragraphs that contain core concepts</li>
                        <li>Type definitions and critical formulas verbatim to reinforce precise terminology</li>
                        <li>Skip sections you've already mastered to focus your typing energy on challenging areas</li>
                    </ul>
                    
                    <h3>3. Synthesis and Note-Taking</h3>
                    <p>After typing through source material, create a second document with your own synthesized notes:</p>
                    <ul>
                        <li>Summarize key concepts in your own words</li>
                        <li>Create connections between different sections or topics</li>
                        <li>Formulate questions about the material to explore later</li>
                        <li>Type these personalized notes to further reinforce learning</li>
                    </ul>
                    
                    <div class="highlight-box">
                        <h4>Pro Tip: The Two-Phase Approach</h4>
                        <p>For maximum retention, use a two-phase approach with TypeCraft: first type through the original material to ensure deep processing, then create and type your own summary notes to solidify understanding through reformulation.</p>
                    </div>
                </div>
                
                <div class="article-page">
                    <h2>Cognitive Benefits of the TypeCraft Method</h2>
                    
                    <h3>Enhanced Focus and Attention</h3>
                    <p>The act of typing creates a continuous feedback loop—your brain must maintain focus to accurately reproduce each character. Unlike passive reading where attention can drift unnoticed, typing immediately reveals lapses in concentration through errors, helping you develop stronger focus over time.</p>
                    
                    <h3>Improved Comprehension</h3>
                    <p>When you type content, you engage with it at a deeper level than when simply reading. This deliberate processing improves understanding, especially for complex materials such as:</p>
                    <ul>
                        <li>Technical documentation</li>
                        <li>Research papers</li>
                        <li>Programming concepts</li>
                        <li>Mathematical explanations</li>
                        <li>Legal documents</li>
                    </ul>
                    
                    <h3>Stronger Memory Formation</h3>
                    <p>TypeCraft leverages the production effect—the phenomenon where information that is actively produced (by typing) is better remembered than information that is merely read. Each keystroke serves as a mini-commitment to the material, creating additional memory hooks.</p>
                    
                    <h2>Practical Applications</h2>
                    
                    <h3>Academic Learning</h3>
                    <p>Students can use TypeCraft to:</p>
                    <ul>
                        <li>Type through lecture notes to reinforce classroom learning</li>
                        <li>Process textbook chapters for better retention</li>
                        <li>Prepare for exams by typing through summary materials</li>
                        <li>Create study guides by typing key concepts</li>
                    </ul>
                    
                    <h3>Professional Development</h3>
                    <p>Professionals can leverage TypeCraft to:</p>
                    <ul>
                        <li>Learn new industry standards or regulations</li>
                        <li>Master technical documentation</li>
                        <li>Absorb business reports and analyses</li>
                        <li>Internalize presentation materials</li>
                    </ul>
                    
                    <h3>Language Learning</h3>
                    <p>Language learners benefit from TypeCraft by:</p>
                    <ul>
                        <li>Reinforcing vocabulary through muscle memory</li>
                        <li>Developing familiarity with grammar structures</li>
                        <li>Practicing spelling in non-native languages</li>
                        <li>Typing through example dialogues and phrases</li>
                    </ul>
                    
                    <h2>Getting Started: A Simple Workflow</h2>
                    <ol>
                        <li><strong>Prepare your material</strong> - Upload a document containing information you want to learn</li>
                        <li><strong>Set a realistic goal</strong> - Aim to type through a manageable section in each session</li>
                        <li><strong>Type with intention</strong> - Focus on understanding, not just reproduction of text</li>
                        <li><strong>Review your errors</strong> - Notice patterns in your mistakes that might indicate attention lapses</li>
                        <li><strong>Create follow-up notes</strong> - After typing through source material, create your own summary document</li>
                    </ol>
                    
                    <h2>Conclusion</h2>
                    <p>TypeCraft transforms the fundamentally passive activity of reading into an active learning experience. By engaging your brain and body simultaneously, you create multiple pathways for information retention and deeper understanding. Whether you're a student tackling complex subjects, a professional mastering new skills, or a lifelong learner expanding your knowledge, the simple act of typing what you read can dramatically enhance how much you learn and retain.</p>
                    
                    <p>Start your TypeCraft journey today, and experience the difference that active, engaged learning can make in your educational and professional pursuits.</p>
                    
                    <div class="article-nav">
                        <button class="btn" id="tryTypeBtn">Try TypeCraft Now</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Completion Modal -->
        <div class="completion-modal" id="completionModal">
            <div class="modal-content">
                <h2>Typing Practice Completed!</h2>
                <p>Congratulations! You have completed the typing practice for this document.</p>
                
                <div class="stats-container">
                    <div class="stat-item">
                        <div class="stat-value" id="finalWpm">0</div>
                        <div class="stat-label">WPM</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="finalAccuracy">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="finalTime">0:00</div>
                        <div class="stat-label">Time</div>
                    </div>
                </div>
                
                <button class="btn" id="tryAgainBtn">Try Again</button>
                <button class="btn btn-secondary" id="newDocumentBtn">New Document</button>
            </div>
        </div>
        
        <!-- Loading Indicator -->
        <div class="loading-indicator" id="loadingIndicator">
            <div class="spinner"></div>
            <p id="loadingText">Processing document...</p>
        </div>
        
        <!-- Save Indicator -->
        <div class="save-indicator" id="saveIndicator">Progress saved</div>
    </div>
    
    <script>
        // PDF.js setup
        pdfjsLib = window['pdfjs-dist/build/pdf'];
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        
        document.addEventListener('DOMContentLoaded', function() {
            // DOM elements - Welcome screen
            const welcomeScreen = document.getElementById('welcomeScreen');
            const dropArea = document.getElementById('dropArea');
            const uploadBtn = document.getElementById('uploadBtn');
            const fileInput = document.getElementById('fileInput');
            const savedSessionsContainer = document.getElementById('savedSessionsContainer');
            const savedSessionsList = document.getElementById('savedSessionsList');
            const learnMoreBtn = document.getElementById('learnMoreBtn');
            
            // DOM elements - Learning view
            const learningView = document.getElementById('learningView');
            const backFromArticleBtn = document.getElementById('backFromArticleBtn');
            const tryTypeBtn = document.getElementById('tryTypeBtn');
            
            // DOM elements - Typing view
            const typingView = document.getElementById('typingView');
            const documentTitle = document.getElementById('documentTitle');
            const documentView = document.getElementById('documentView');
            const documentViewport = document.getElementById('documentViewport');
            const backToMainBtn = document.getElementById('backToMainBtn');
            const resetTypingBtn = document.getElementById('resetTypingBtn');
            const saveProgressBtn = document.getElementById('saveProgressBtn');
            
            // DOM elements - Pagination controls
            const paginationControls = document.getElementById('paginationControls');
            const prevPageBtn = document.getElementById('prevPageBtn');
            const nextPageBtn = document.getElementById('nextPageBtn');
            const skipPageBtn = document.getElementById('skipPageBtn');
            const currentPageEl = document.getElementById('currentPage');
            const totalPagesEl = document.getElementById('totalPages');
            
            // DOM elements - Progress indicators
            const wpmValue = document.getElementById('wpmValue');
            const accuracyValue = document.getElementById('accuracyValue');
            const progressValue = document.getElementById('progressValue');
            
            // DOM elements - Completion modal
            const completionModal = document.getElementById('completionModal');
            const finalWpm = document.getElementById('finalWpm');
            const finalAccuracy = document.getElementById('finalAccuracy');
            const finalTime = document.getElementById('finalTime');
            const tryAgainBtn = document.getElementById('tryAgainBtn');
            const newDocumentBtn = document.getElementById('newDocumentBtn');
            
            // DOM elements - Loading and save indicators
            const loadingIndicator = document.getElementById('loadingIndicator');
            const loadingText = document.getElementById('loadingText');
            const saveIndicator = document.getElementById('saveIndicator');
            
            // State variables
            let currentFile = null;
            let currentFileName = '';
            let typeableElements = [];
            let currentElementIndex = 0;
            let currentCharIndex = 0;
            let startTime = null;
            let errors = 0;
            let totalTyped = 0;
            let correctlyTyped = 0; // Track correctly typed characters for accurate WPM
            let isTyping = false;
            let fileContent = null; // Store file content for saving progress
            let fileType = ''; // Store file type for saving progress
            
            // Pagination variables
            let documentPages = []; // Array to store pages
            let currentPageIndex = 0; // Current page index
            let pageTypeableElements = []; // Typeable elements for current page
            let totalTypeableElements = []; // All typeable elements across all pages
            
            // Check for saved sessions
            checkSavedSessions();
            
            // Event listeners for file input
            uploadBtn.addEventListener('click', () => fileInput.click());
            
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    currentFile = file;
                    currentFileName = file.name;
                    processDocument(file);
                }
            });
            
            // Event listeners for learning article
            learnMoreBtn.addEventListener('click', () => {
                welcomeScreen.style.display = 'none';
                learningView.style.display = 'block';
            });
            
            backFromArticleBtn.addEventListener('click', () => {
                learningView.style.display = 'none';
                welcomeScreen.style.display = 'block';
            });
            
            tryTypeBtn.addEventListener('click', () => {
                learningView.style.display = 'none';
                welcomeScreen.style.display = 'block';
            });
            
            // Drag and drop functionality
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.style.borderColor = '#6366f1';
                dropArea.style.backgroundColor = 'rgba(99, 102, 241, 0.1)';
            });
            
            dropArea.addEventListener('dragleave', () => {
                dropArea.style.borderColor = '#cbd5e1';
                dropArea.style.backgroundColor = 'transparent';
            });
            
            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.style.borderColor = '#cbd5e1';
                dropArea.style.backgroundColor = 'transparent';
                
                const file = e.dataTransfer.files[0];
                if (file) {
                    currentFile = file;
                    currentFileName = file.name;
                    processDocument(file);
                }
            });
            
            // Button event listeners
            backToMainBtn.addEventListener('click', () => {
                typingView.style.display = 'none';
                welcomeScreen.style.display = 'block';
                checkSavedSessions(); // Refresh saved sessions list
            });
            
            resetTypingBtn.addEventListener('click', () => {
                resetTypingSession();
            });
            
            saveProgressBtn.addEventListener('click', () => {
                saveProgress();
            });
            
            tryAgainBtn.addEventListener('click', () => {
                completionModal.style.display = 'none';
                resetTypingSession();
            });
            
            newDocumentBtn.addEventListener('click', () => {
                completionModal.style.display = 'none';
                typingView.style.display = 'none';
                welcomeScreen.style.display = 'block';
                fileInput.value = '';
                checkSavedSessions(); // Refresh saved sessions list
            });
            
            // Pagination event listeners
            prevPageBtn.addEventListener('click', () => {
                if (currentPageIndex > 0) {
                    navigateToPage(currentPageIndex - 1);
                }
            });
            
            nextPageBtn.addEventListener('click', () => {
                if (currentPageIndex < documentPages.length - 1) {
                    navigateToPage(currentPageIndex + 1);
                }
            });
            
            skipPageBtn.addEventListener('click', () => {
                if (currentPageIndex < documentPages.length - 1) {
                    // Mark all elements on current page as completed
                    pageTypeableElements.forEach(item => {
                        item.element.classList.add('completed');
                        
                        // Mark all characters as correct
                        const charSpans = item.element.querySelectorAll('.text-char');
                        charSpans.forEach(span => {
                            span.classList.add('correct');
                        });
                    });
                    
                    // Update the total typeable elements progress
                    const startIndex = getPageStartIndex(currentPageIndex);
                    const endIndex = getPageEndIndex(currentPageIndex);
                    
                    for (let i = startIndex; i <= endIndex; i++) {
                        if (i < totalTypeableElements.length) {
                            totalTypeableElements[i].completed = true;
                        }
                    }
                    
                    // Navigate to next page
                    navigateToPage(currentPageIndex + 1);
                    
                    // Update stats
                    updateStats();
                }
            });
            
            // Add keyboard event listener for the entire document
            document.addEventListener('keydown', handleKeyDown);
            
            // Check for saved sessions
            function checkSavedSessions() {
                const savedSessions = getSavedSessions();
                
                if (savedSessions.length > 0) {
                    savedSessionsContainer.style.display = 'block';
                    savedSessionsList.innerHTML = '';
                    
                    savedSessions.forEach(session => {
                        const sessionItem = document.createElement('div');
                        sessionItem.className = 'card';
                        sessionItem.style.marginBottom = '10px';
                        sessionItem.style.cursor = 'pointer';
                        
                        const progress = Math.round(session.progress * 100);
                        
                        sessionItem.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <h4>${session.fileName}</h4>
                                    <p>Progress: ${progress}%</p>
                                </div>
                                <div>
                                    <button class="btn" data-filename="${session.fileName}">Continue</button>
                                    <button class="btn btn-secondary" data-filename="${session.fileName}" data-action="delete">Delete</button>
                                </div>
                            </div>
                        `;
                        
                        // Add event listener to the continue button
                        sessionItem.querySelector('button[data-action="delete"]').addEventListener('click', (e) => {
                            e.stopPropagation();
                            const fileName = e.target.dataset.filename;
                            deleteSavedSession(fileName);
                            checkSavedSessions();
                        });
                        
                        // Add event listener to the continue button
                        sessionItem.querySelector('button:not([data-action])').addEventListener('click', () => {
                            loadSavedSession(session.fileName);
                        });
                        
                        savedSessionsList.appendChild(sessionItem);
                    });
                } else {
                    savedSessionsContainer.style.display = 'none';
                }
            }
            
            // Text processing functions
            
            // Clean up text for better typing experience
            function cleanText(text) {
                return text
                    // Replace multiple spaces with a single space
                    .replace(/\s+/g, ' ')
                    // Replace tabs with spaces
                    .replace(/\t/g, ' ')
                    // Replace non-breaking spaces with regular spaces
                    .replace(/\u00A0/g, ' ')
                    // Replace typographically fancy quotes with straight quotes
                    .replace(/[\u2018\u2019]/g, "'")
                    .replace(/[\u201C\u201D]/g, '"')
                    // Replace em-dashes and en-dashes with hyphens
                    .replace(/[\u2013\u2014]/g, '-')
                    // Replace ellipsis with three periods
                    .replace(/\u2026/g, '...')
                    // Trim extra whitespace
                    .trim();
            }
            
            // Enhanced text processing with improved spacing and special character handling
            function processTextContent(text, isHeading = false) {
                // Apply basic cleaning
                let processedText = cleanText(text);
                
                // Basic spacing fixes for all text
                processedText = processedText
                    // Add space after punctuation if followed by a capital letter
                    .replace(/([.,!?;:])([A-Z])/g, '$1 $2')
                    // Add space between lowercase and uppercase (camelCase detection)
                    .replace(/([a-z])([A-Z])/g, '$1 $2')
                    // Fix hashtags with missing spaces
                    .replace(/(#)([A-Z])/g, '$1 $2')
                    // Fix section headers 
                    .replace(/(##?)([A-Za-z])/g, '$1 $2')
                    // Add space after # if needed
                    .replace(/#([A-Za-z])/g, '# $1');
                
                // Apply more aggressive spacing corrections for headings
                if (isHeading) {
                    processedText = processedText
                        // Look for multiple capital letters in a row potentially indicating new words
                        .replace(/([A-Z])([A-Z][a-z])/g, '$1 $2')
                        // Look for lowercase followed by multiple caps (potential acronym/new word)
                        .replace(/([a-z])([A-Z][A-Z])/g, '$1 $2')
                        // Fix compound words that might be smashed together (more aggressive)
                        .replace(/([a-z]{3,})([A-Z])/g, '$1 $2');
                }
                
                return processedText;
            }
            
            // Convert Markdown to HTML
            function processMarkdown(text) {
                return marked.parse(text);
            }
            
            // Function to determine if content is likely markdown
               function isLikelyMarkdown(text) {
                   // Check for common markdown indicators
                   return (
                       /^#+\s/.test(text) || // Headers
                       /\*\*.*\*\*/.test(text) || // Bold
                       /\*.*\*/.test(text) || // Italic
                       /\[.*\]\(.*\)/.test(text) || // Links
                       /^>\s/.test(text) || // Blockquotes
                       /^-\s/.test(text) || // Unordered lists
                       /^[0-9]+\.\s/.test(text) || // Ordered lists
                       /^```/.test(text) || // Code blocks
                       /^---/.test(text) // Horizontal rules
                   );
               }
           
           // Process the document based on its type
           function processDocument(file) {
               // Show loading indicator
               loadingIndicator.style.display = 'flex';
               
               // Set document title
               documentTitle.textContent = file.name;
               
               // Clear previous typeable elements
               typeableElements = [];
               documentPages = [];
               totalTypeableElements = [];
               currentPageIndex = 0;
               
               fileType = file.type.toLowerCase();
               const fileName = file.name.toLowerCase();
               
               if (fileType === 'application/pdf' || fileName.endsWith('.pdf')) {
                   loadingText.textContent = 'Processing PDF document...';
                   processPdfDocument(file);
               } else if (fileType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
                         fileName.endsWith('.docx')) {
                   loadingText.textContent = 'Processing Word document...';
                   processWordDocument(file);
               } else if (fileType === 'application/msword' || fileName.endsWith('.doc')) {
                   loadingText.textContent = 'Processing Word document...';
                   alert('Classic Word (.doc) files have limited support. For best results, save as .docx or PDF.');
                   processTextDocument(file); // Fallback to text processing
               } else if (fileType === 'text/plain' || fileName.endsWith('.txt')) {
                   loadingText.textContent = 'Processing text document...';
                   processTextDocument(file);
               } else if (fileType === 'text/html' || fileName.endsWith('.html') || fileName.endsWith('.htm')) {
                   loadingText.textContent = 'Processing HTML document...';
                   processHtmlDocument(file);
               } else if (fileType === 'text/markdown' || fileName.endsWith('.md') || fileName.endsWith('.markdown')) {
                   loadingText.textContent = 'Processing Markdown document...';
                   processMarkdownDocument(file);
               } else if (fileType === 'application/rtf' || fileName.endsWith('.rtf')) {
                   loadingText.textContent = 'Processing RTF document...';
                   processTextDocument(file); // Basic fallback for RTF
               } else {
                   alert('Unsupported file type. Please use PDF, DOCX, TXT, HTML, Markdown, or RTF files.');
                   loadingIndicator.style.display = 'none';
               }
           }
           
           // Process a PDF document with improved text extraction and pagination
           async function processPdfDocument(file) {
               try {
                   // Read the file content for saving later
                   const reader = new FileReader();
                   reader.onload = (e) => {
                       fileContent = e.target.result;
                   };
                   reader.readAsArrayBuffer(file);
                   
                   // Create a URL for the PDF
                   const fileURL = URL.createObjectURL(file);
                   
                   // Load the PDF document
                   const loadingTask = pdfjsLib.getDocument(fileURL);
                   const pdf = await loadingTask.promise;
                   
                   // Clear the document viewport
                   documentViewport.innerHTML = '';
                   
                   // Create main container
                   const mainContainer = document.createElement('div');
                   mainContainer.className = 'document-text';
                   documentViewport.appendChild(mainContainer);
                   
                   // Process each page
                   const MAX_ELEMENTS_PER_PAGE = 20; // Limit elements per page to prevent performance issues
                   let currentPageContainer = null;
                   let currentPageElements = [];
                   let pageIndex = 0;
                   
                   // Update loading text to show progress
                   const totalPages = pdf.numPages;
                   
                   for (let i = 1; i <= totalPages; i++) {
                       loadingText.textContent = `Processing page ${i} of ${totalPages}...`;
                       
                       // Get the page
                       const page = await pdf.getPage(i);
                       
                       // Extract text content
                       const textContent = await page.getTextContent();
                       
                       // Create a new page container if needed
                       if (!currentPageContainer || currentPageElements.length >= MAX_ELEMENTS_PER_PAGE) {
                           currentPageContainer = document.createElement('div');
                           currentPageContainer.className = 'document-page';
                           currentPageContainer.dataset.pageIndex = pageIndex;
                           mainContainer.appendChild(currentPageContainer);
                           
                           documentPages.push(currentPageContainer);
                           currentPageElements = [];
                           pageIndex++;
                       }
                       
                       // Add a page header
                       const pageHeader = document.createElement('h3');
                       pageHeader.textContent = `Page ${i} of ${totalPages}`;
                       pageHeader.style.color = '#64748b';
                       pageHeader.style.marginBottom = '20px';
                       currentPageContainer.appendChild(pageHeader);
                       
                       // Improved text extraction with better position tracking
                       // Group text items by their vertical position (y-coordinate)
                       const textByPosition = {};
                       
                       textContent.items.forEach(item => {
                           const y = Math.round(item.transform[5]); // Round to handle minor position differences
                           if (!textByPosition[y]) {
                               textByPosition[y] = [];
                           }
                           textByPosition[y].push(item);
                       });
                       
                       // Sort positions from top to bottom
                       const positions = Object.keys(textByPosition).map(Number).sort((a, b) => b - a);
                       
                       // Process text line by line
                       let paragraphText = '';
                       let lastPosition = null;
                       
                       for (const pos of positions) {
                           // Sort items within a line from left to right
                           const lineItems = textByPosition[pos].sort((a, b) => a.transform[4] - b.transform[4]);
                           
                           // Convert line to text
                           let line = lineItems.map(item => item.str).join(' ');
                           line = cleanText(line);
                           
                           // Check if this is likely a header (short line, all caps, etc.)
                           const isLikelyHeading = line.trim().length < 100 && 
                                                (line.toUpperCase() === line || 
                                                 /^[A-Z][\w\s]+$/.test(line));
                           
                           // If it's likely a heading or if there's a big gap, create a new paragraph
                           if (isLikelyHeading || (lastPosition && Math.abs(pos - lastPosition) > 15)) {
                               // Create paragraph from accumulated text
                               if (paragraphText.trim()) {
                                   const para = document.createElement('p');
                                   para.textContent = processTextContent(paragraphText);
                                   currentPageContainer.appendChild(para);
                                   currentPageElements.push(para);
                               }
                               
                               paragraphText = '';
                               
                               // Create heading if needed
                               if (isLikelyHeading) {
                                   const heading = document.createElement(line.length < 30 ? 'h2' : 'h3');
                                   heading.textContent = processTextContent(line, true);
                                   currentPageContainer.appendChild(heading);
                                   currentPageElements.push(heading);
                                   continue; // Skip adding to paragraph text
                               }
                           }
                           
                           // Add to paragraph text
                           paragraphText += line + ' ';
                           lastPosition = pos;
                       }
                       
                       // Add final paragraph
                       if (paragraphText.trim()) {
                           const para = document.createElement('p');
                           para.textContent = processTextContent(paragraphText);
                           currentPageContainer.appendChild(para);
                           currentPageElements.push(para);
                       }
                   }
                   
                   // Set up document pagination
                   setupPagination();
                   
                   // Hide loading indicator and show typing view
                   loadingIndicator.style.display = 'none';
                   welcomeScreen.style.display = 'none';
                   typingView.style.display = 'block';
                   
                   // Initialize the typing session
                   initializeTypingSession();
                   
               } catch (error) {
                   console.error('Error processing PDF:', error);
                   alert('There was an error processing the PDF. Try a different document or format.');
                   loadingIndicator.style.display = 'none';
               }
           }
// Process a Word document using Mammoth.js with pagination
           function processWordDocument(file) {
               const reader = new FileReader();
               
               reader.onload = function(e) {
                   // Save the file content for later
                   fileContent = e.target.result;
                   
                   const arrayBuffer = e.target.result;
                   
                   mammoth.convertToHtml({ arrayBuffer: arrayBuffer })
                       .then(result => {
                           // Create main container
                           const mainContainer = document.createElement('div');
                           mainContainer.className = 'document-text';
                           
                           // Set the HTML content
                           const tempContainer = document.createElement('div');
                           tempContainer.innerHTML = result.value;
                           
                           // Process headings to fix spacing issues
                           const headings = tempContainer.querySelectorAll('h1, h2, h3, h4, h5, h6');
                           headings.forEach(heading => {
                               heading.textContent = processTextContent(heading.textContent, true);
                           });
                           
                           // Process paragraphs for better spacing
                           const paragraphs = tempContainer.querySelectorAll('p');
                           paragraphs.forEach(para => {
                               para.textContent = processTextContent(para.textContent);
                           });
                           
                           // Create pages
                           createPagesFromElements(tempContainer, mainContainer);
                           
                           // Clear viewport and add the document
                           documentViewport.innerHTML = '';
                           documentViewport.appendChild(mainContainer);
                           
                           // Set up document pagination
                           setupPagination();
                           
                           // Hide loading indicator and show typing view
                           loadingIndicator.style.display = 'none';
                           welcomeScreen.style.display = 'none';
                           typingView.style.display = 'block';
                           
                           // Initialize the typing session
                           initializeTypingSession();
                       })
                       .catch(error => {
                           console.error('Error processing Word document:', error);
                           alert('There was an error processing the Word document. Try converting to PDF for better results.');
                           processTextDocument(file); // Fallback to text processing
                       });
               };
               
               reader.onerror = function() {
                   alert('There was an error reading the file. Please try again.');
                   loadingIndicator.style.display = 'none';
               };
               
               reader.readAsArrayBuffer(file);
           }
           
           // Process a text document with pagination
           function processTextDocument(file) {
               const reader = new FileReader();
               
               reader.onload = function(e) {
                   // Save the file content for later
                   fileContent = e.target.result;
                   
                   const text = e.target.result;
                   
                   // Check if it might be markdown
                   if (isLikelyMarkdown(text)) {
                       // Process as markdown
                       const html = processMarkdown(text);
                       const tempContainer = document.createElement('div');
                       tempContainer.innerHTML = html;
                       
                       // Create main container
                       const mainContainer = document.createElement('div');
                       mainContainer.className = 'document-text';
                       
                       // Create pages
                       createPagesFromElements(tempContainer, mainContainer);
                       
                       // Clear viewport and add the document
                       documentViewport.innerHTML = '';
                       documentViewport.appendChild(mainContainer);
                       
                       // Set up document pagination
                       setupPagination();
                       
                       // Hide loading indicator and show typing view
                       loadingIndicator.style.display = 'none';
                       welcomeScreen.style.display = 'none';
                       typingView.style.display = 'block';
                       
                       // Initialize the typing session
                       initializeTypingSession();
                       return;
                   }
                   
                   // Create main container
                   const mainContainer = document.createElement('div');
                   mainContainer.className = 'document-text';
                   
                   // Split text into paragraphs
                   const paragraphs = text.split(/\n\s*\n/);
                   
                   // Create pages
                   const MAX_PARAGRAPHS_PER_PAGE = 15;
                   let currentPageContainer = null;
                   let currentPageElements = [];
                   let pageIndex = 0;
                   
                   // Process each paragraph
                   paragraphs.forEach((paragraph, index) => {
                       if (!paragraph.trim()) return;
                       
                       // Create a new page container if needed
                       if (!currentPageContainer || currentPageElements.length >= MAX_PARAGRAPHS_PER_PAGE) {
                           currentPageContainer = document.createElement('div');
                           currentPageContainer.className = 'document-page';
                           currentPageContainer.dataset.pageIndex = pageIndex;
                           mainContainer.appendChild(currentPageContainer);
                           
                           documentPages.push(currentPageContainer);
                           currentPageElements = [];
                           pageIndex++;
                       }
                       
                       // Check if this is likely a heading (short line, all caps, etc.)
                       const isLikelyHeading = paragraph.trim().length < 100 && 
                                            (paragraph.toUpperCase() === paragraph || 
                                             /^#+ /.test(paragraph) || 
                                             /^[A-Z][\w\s]+$/.test(paragraph));
                       
                       // Create appropriate element based on content
                       if (isLikelyHeading) {
                           // Create heading element
                           const headingLevel = paragraph.trim().length < 30 ? 'h2' : 'h3';
                           const heading = document.createElement(headingLevel);
                           // Apply enhanced text processing for headings
                           heading.textContent = processTextContent(paragraph, true);
                           currentPageContainer.appendChild(heading);
                           currentPageElements.push(heading);
                       } else {
                           // Create paragraph element
                           const para = document.createElement('p');
                           para.style.marginBottom = '16px';
                           para.style.lineHeight = '1.8';
                           para.style.whiteSpace = 'pre-wrap'; // Preserve whitespace
                           
                           // Apply basic text processing
                           para.textContent = processTextContent(paragraph, false);
                           
                           // Add to document
                           currentPageContainer.appendChild(para);
                           currentPageElements.push(para);
                       }
                   });
                   
                   // Clear viewport and add the document
                   documentViewport.innerHTML = '';
                   documentViewport.appendChild(mainContainer);
                   
                   // Set up document pagination
                   setupPagination();
                   
                   // Hide loading indicator and show typing view
                   loadingIndicator.style.display = 'none';
                   welcomeScreen.style.display = 'none';
                   typingView.style.display = 'block';
                   
                   // Initialize the typing session
                   initializeTypingSession();
               };
               
               reader.onerror = function() {
                   alert('There was an error reading the file. Please try again.');
                   loadingIndicator.style.display = 'none';
               };
               
               reader.readAsText(file);
           }
           
           // Process an HTML document with pagination
           function processHtmlDocument(file) {
               const reader = new FileReader();
               
               reader.onload = function(e) {
                   // Save the file content for later
                   fileContent = e.target.result;
                   
                   const htmlContent = e.target.result;
                   
                   // Create a temporary container for the HTML content
                   const tempContainer = document.createElement('div');
                   
                   // Set the HTML content with some sanitization
                   // Remove scripts and potentially harmful elements
                   const sanitizedHtml = htmlContent
                       .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                       .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '');
                       
                   tempContainer.innerHTML = sanitizedHtml;
                   
                   // Process headings to fix spacing issues
                   const headings = tempContainer.querySelectorAll('h1, h2, h3, h4, h5, h6');
                   headings.forEach(heading => {
                       heading.textContent = processTextContent(heading.textContent, true);
                   });
                   
                   // Create main container
                   const mainContainer = document.createElement('div');
                   mainContainer.className = 'document-text';
                   
                   // Create pages
                   createPagesFromElements(tempContainer, mainContainer);
                   
                   // Clear viewport and add the document
                   documentViewport.innerHTML = '';
                   documentViewport.appendChild(mainContainer);
                   
                   // Set up document pagination
                   setupPagination();
                   
                   // Hide loading indicator and show typing view
                   loadingIndicator.style.display = 'none';
                   welcomeScreen.style.display = 'none';
                   typingView.style.display = 'block';
                   
                   // Initialize the typing session
                   initializeTypingSession();
               };
               
               reader.onerror = function() {
                   alert('There was an error reading the HTML file. Please try again.');
                   loadingIndicator.style.display = 'none';
               };
               
               reader.readAsText(file);
           }
           
           // Process a Markdown document
           function processMarkdownDocument(file) {
               const reader = new FileReader();
               
               reader.onload = function(e) {
                   // Save the file content for later
                   fileContent = e.target.result;
                   
                   const markdownContent = e.target.result;
                   
                   // Convert Markdown to HTML
                   const html = processMarkdown(markdownContent);
                   
                   // Create a temporary container
                   const tempContainer = document.createElement('div');
                   tempContainer.innerHTML = html;
                   
                   // Process headings to fix spacing issues
                   const headings = tempContainer.querySelectorAll('h1, h2, h3, h4, h5, h6');
                   headings.forEach(heading => {
                       heading.textContent = processTextContent(heading.textContent, true);
                   });
                   
                   // Create main container
                   const mainContainer = document.createElement('div');
                   mainContainer.className = 'document-text';
                   
                   // Create pages
                   createPagesFromElements(tempContainer, mainContainer);
                   
                   // Clear viewport and add the document
                   documentViewport.innerHTML = '';
                   documentViewport.appendChild(mainContainer);
                   
                   // Set up document pagination
                   setupPagination();
                   
                   // Hide loading indicator and show typing view
                   loadingIndicator.style.display = 'none';
                   welcomeScreen.style.display = 'none';
                   typingView.style.display = 'block';
                   
                   // Initialize the typing session
                   initializeTypingSession();
               };
               
               reader.onerror = function() {
                   alert('There was an error reading the Markdown file. Please try again.');
                   loadingIndicator.style.display = 'none';
               };
               
               reader.readAsText(file);
           }
           
           // Create pages from a container of elements
           function createPagesFromElements(sourceContainer, targetContainer) {
               // Get all relevant text elements
               const elements = sourceContainer.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote, pre, table');
               
               // Constants for pagination
               const MAX_ELEMENTS_PER_PAGE = 15;
               let currentPageContainer = null;
               let currentPageElements = [];
               let pageIndex = 0;
               
               // Process each element
               elements.forEach((element, index) => {
                   // Skip empty elements
                   if (!element.textContent.trim()) return;
                   
                   // Create a new page container if needed
                   if (!currentPageContainer || currentPageElements.length >= MAX_ELEMENTS_PER_PAGE) {
                       currentPageContainer = document.createElement('div');
                       currentPageContainer.className = 'document-page';
                       currentPageContainer.dataset.pageIndex = pageIndex;
                       targetContainer.appendChild(currentPageContainer);
                       
                       documentPages.push(currentPageContainer);
                       currentPageElements = [];
                       pageIndex++;
                       
                       // Add page number as a header
                       const pageHeader = document.createElement('h3');
                       pageHeader.textContent = `Page ${pageIndex} of ${Math.ceil(elements.length / MAX_ELEMENTS_PER_PAGE)}`;
                       pageHeader.style.color = '#64748b';
                       pageHeader.style.marginBottom = '20px';
                       currentPageContainer.appendChild(pageHeader);
                   }
                   
                   // Clone the element and add to the current page
                   const clonedElement = element.cloneNode(true);
                   currentPageContainer.appendChild(clonedElement);
                   currentPageElements.push(clonedElement);
               });
           }
           
           // Set up pagination controls
           function setupPagination() {
               // Update total pages count
               totalPagesEl.textContent = documentPages.length;
               currentPageEl.textContent = '1';
               
               // Show the first page
               if (documentPages.length > 0) {
                   documentPages.forEach(page => {
                       page.classList.remove('active');
                   });
                   documentPages[0].classList.add('active');
               }
               
               // Update pagination button states
               updatePaginationButtons();
               
               // Show pagination controls if there are multiple pages
               if (documentPages.length > 1) {
                   paginationControls.style.display = 'flex';
               } else {
                   paginationControls.style.display = 'none';
               }
           }
           
           // Update pagination button states
           function updatePaginationButtons() {
               prevPageBtn.disabled = currentPageIndex === 0;
               nextPageBtn.disabled = currentPageIndex === documentPages.length - 1;
           }
           
           // Navigate to a specific page
           function navigateToPage(pageIndex) {
               if (pageIndex < 0 || pageIndex >= documentPages.length) return;
               
               // Update current page index
               currentPageIndex = pageIndex;
               
               // Hide all pages except the current one
               documentPages.forEach((page, index) => {
                   if (index === currentPageIndex) {
                       page.classList.add('active');
                   } else {
                       page.classList.remove('active');
                   }
               });
               
               // Update pagination info
               currentPageEl.textContent = currentPageIndex + 1;
               
               // Update pagination buttons
               updatePaginationButtons();
               
               // Extract typeable elements for current page
               extractTypeableElementsFromPage(documentPages[currentPageIndex]);
               
               // Reset typing session for this page
               resetPageTypingSession();
           }
           
           // Get the start index for typeable elements on a page
           function getPageStartIndex(pageIndex) {
               let startIndex = 0;
               for (let i = 0; i < pageIndex; i++) {
                   const pageElements = documentPages[i].querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th');
                   startIndex += pageElements.length;
               }
               return startIndex;
           }
           
           // Get the end index for typeable elements on a page
           function getPageEndIndex(pageIndex) {
               const startIndex = getPageStartIndex(pageIndex);
               const pageElements = documentPages[pageIndex].querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th');
               return startIndex + pageElements.length - 1;
           }
            // Extract typeable elements from a specific page
           function extractTypeableElementsFromPage(pageContainer) {
               // Clear previous page typeable elements
               pageTypeableElements = [];
               
               // Get all text nodes that should be typeable
               const textElements = pageContainer.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th, blockquote, pre');
               
               textElements.forEach(element => {
                   // Skip elements with no text
                   if (!element.textContent.trim()) return;
                   
                   // Check if this is a heading
                   const isHeading = /^h[1-6]$/i.test(element.tagName);
                   
                   // Create a wrapper for this element if it doesn't exist
                   let wrapper = element.querySelector('.typeable-wrapper');
                   if (!wrapper) {
                       // Save the original text
                       const originalText = cleanText(element.textContent);
                       
                       // Create a wrapper
                       wrapper = document.createElement('div');
                       wrapper.className = 'typeable-wrapper';
                       wrapper.dataset.text = originalText;
                       wrapper.tabIndex = 0; // Make it focusable
                       
                       // Replace the element's content with the wrapper
                       element.innerHTML = '';
                       element.appendChild(wrapper);
                       
                       // Create spans for each character
                       for (let i = 0; i < originalText.length; i++) {
                           const charSpan = document.createElement('span');
                           charSpan.className = 'text-char';
                           charSpan.textContent = originalText[i];
                           charSpan.dataset.index = i;
                           wrapper.appendChild(charSpan);
                       }
                   }
                   
                   // Add to typeable elements
                   const textItem = {
                       element: wrapper,
                       text: wrapper.dataset.text,
                       index: pageTypeableElements.length,
                       isHeading: isHeading,
                       completed: false
                   };
                   
                   pageTypeableElements.push(textItem);
                   
                   // Add to total typeable elements
                   totalTypeableElements.push(textItem);
               });
               
               // Reset element index for the current page
               currentElementIndex = 0;
               currentCharIndex = 0;
           }
           
           // Extract typeable elements from all pages
           function extractTypeableElementsFromDoc(container) {
               // Clear previous typeable elements
               totalTypeableElements = [];
               
               // Process each page
               documentPages.forEach((page) => {
                   const textElements = page.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th, blockquote, pre');
                   
                   textElements.forEach(element => {
                       // Skip elements with no text
                       if (!element.textContent.trim()) return;
                       
                       // Check if this is a heading
                       const isHeading = /^h[1-6]$/i.test(element.tagName);
                       
                       // Create a wrapper for this element if it doesn't exist
                       let wrapper = element.querySelector('.typeable-wrapper');
                       if (!wrapper) {
                           // Save the original text
                           const originalText = cleanText(element.textContent);
                           
                           // Create a wrapper
                           wrapper = document.createElement('div');
                           wrapper.className = 'typeable-wrapper';
                           wrapper.dataset.text = originalText;
                           wrapper.tabIndex = 0; // Make it focusable
                           
                           // Replace the element's content with the wrapper
                           element.innerHTML = '';
                           element.appendChild(wrapper);
                           
                           // Create spans for each character
                           for (let i = 0; i < originalText.length; i++) {
                               const charSpan = document.createElement('span');
                               charSpan.className = 'text-char';
                               charSpan.textContent = originalText[i];
                               charSpan.dataset.index = i;
                               wrapper.appendChild(charSpan);
                           }
                       }
                       
                       // Add to total typeable elements
                       totalTypeableElements.push({
                           element: wrapper,
                           text: wrapper.dataset.text,
                           index: totalTypeableElements.length,
                           isHeading: isHeading,
                           completed: false
                       });
                   });
               });
           }
           
           // Initialize the typing session
           function initializeTypingSession() {
               // Reset state if not loading a saved session
               if (!isLoadingSavedSession) {
                   currentElementIndex = 0;
                   currentCharIndex = 0;
                   startTime = null;
                   errors = 0;
                   totalTyped = 0;
                   correctlyTyped = 0;
                   isTyping = false;
               }
               
               // Set flag back to false
               isLoadingSavedSession = false;
               
               // Reset stats
               wpmValue.textContent = '0';
               accuracyValue.textContent = '0%';
               progressValue.textContent = '0%';
               
               // Setup the first page
               if (documentPages.length > 0) {
                   navigateToPage(0);
               }
               
               // Set focus to the document for typing
               documentViewport.focus();
           }
           
           // Reset typing session for current page
           function resetPageTypingSession() {
               // Only reset current page elements
               if (pageTypeableElements.length > 0) {
                   currentElementIndex = 0;
                   currentCharIndex = 0;
                   
                   // Reset text document elements on current page
                   const wrappers = documentPages[currentPageIndex].querySelectorAll('.typeable-wrapper');
                   wrappers.forEach(wrapper => {
                       const isCompleted = wrapper.classList.contains('completed');
                       wrapper.classList.remove('current', 'completed');
                       
                       // Reset character spans
                       wrapper.querySelectorAll('.text-char').forEach(charSpan => {
                           charSpan.classList.remove('current', 'correct', 'incorrect');
                       });
                       
                       // Restore completed state if it was already completed
                       if (isCompleted) {
                           wrapper.classList.add('completed');
                           wrapper.querySelectorAll('.text-char').forEach(charSpan => {
                               charSpan.classList.add('correct');
                           });
                       }
                   });
                   
                   // Highlight the first element
                   highlightCurrentElement();
               }
           }
           
           // Highlight the current typeable element
           function highlightCurrentElement() {
               // If we have no typeable elements, return
               if (pageTypeableElements.length === 0) return;
               
               // If we've reached the end of current page
               if (currentElementIndex >= pageTypeableElements.length) {
                   // Check if there are more pages
                   if (currentPageIndex < documentPages.length - 1) {
                       // Move to the next page
                       navigateToPage(currentPageIndex + 1);
                   } else {
                       // We've reached the end of the document
                       showCompletionModal();
                   }
                   return;
               }
               
               // Get the current element
               const currentItem = pageTypeableElements[currentElementIndex];
               
               // Remove current class from all wrappers on this page
               documentPages[currentPageIndex].querySelectorAll('.typeable-wrapper').forEach(wrapper => {
                   wrapper.classList.remove('current');
               });
               
               // Add current class to this wrapper
               currentItem.element.classList.add('current');
               
               // Scroll to the element
               currentItem.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
               
               // Update current char highlighting
               highlightCurrentChar(currentItem.element);
           }
           
           // Highlight the current character
           function highlightCurrentChar(element) {
               // Get the current element
               const currentItem = pageTypeableElements[currentElementIndex];
               if (!currentItem || !currentItem.element) return;
               
               // Get all character spans
               const charSpans = currentItem.element.querySelectorAll('.text-char');
               
               // Remove current class from all spans
               charSpans.forEach(span => {
                   span.classList.remove('current');
               });
               
               // Add current class to the current character span
               if (currentCharIndex < charSpans.length) {
                   charSpans[currentCharIndex].classList.add('current');
                   
                   // Add cursor after the current character
                   const cursor = document.querySelector('.typing-cursor');
                   if (cursor) cursor.remove();
                   
                   const newCursor = document.createElement('span');
                   newCursor.className = 'typing-cursor';
                   charSpans[currentCharIndex].appendChild(newCursor);
               }
           }
           
           // Handle key down events for typing
           function handleKeyDown(e) {
               // Only handle typing when the typing view is shown
               if (typingView.style.display !== 'block') return;
               
               // Skip if we've reached the end of all pages
               if (currentPageIndex >= documentPages.length) return;
               
               // Skip if we've reached the end of current page elements
               if (currentElementIndex >= pageTypeableElements.length) return;
               
               // Skip control keys except Backspace
               if (e.ctrlKey || e.altKey || e.metaKey) return;
               
               // Start timing on first keypress
               if (!isTyping) {
                   startTime = new Date();
                   isTyping = true;
               }
               
               // Get the current element and its text
               const currentItem = pageTypeableElements[currentElementIndex];
               const text = currentItem.text;
               
               // Handle Backspace key
               if (e.key === 'Backspace') {
                   // Prevent default behavior
                   e.preventDefault();
                   
                   // Only allow backspace if we're not at the beginning
                   if (currentCharIndex > 0) {
                       currentCharIndex--;
                       
                       // Remove any correct/incorrect classes from the current character
                       const charSpans = currentItem.element.querySelectorAll('.text-char');
                       if (currentCharIndex < charSpans.length) {
                           charSpans[currentCharIndex].classList.remove('correct', 'incorrect');
                       }
                       highlightCurrentChar(currentItem.element);
                   } else if (currentElementIndex > 0) {
                       // At the beginning of current element, go to previous element
                       currentElementIndex--;
                       const prevItem = pageTypeableElements[currentElementIndex];
                       // Set cursor at the end of the previous element
                       currentCharIndex = prevItem.text.length;
                       
                       // Mark the current element as not completed
                       prevItem.element.classList.remove('completed');
                       prevItem.element.classList.add('current');
                       
                       // Update highlighting
                       highlightCurrentElement();
                   }
                   
                   // Update stats
                   updateStats();
                   return;
               }
               
               // Skip other special keys
               if (e.key.length > 1) return;
               
               // Prevent default behavior to avoid page scrolling, etc.
               e.preventDefault();
               
               // If we've reached the end of the current element's text
               if (currentCharIndex >= text.length) {
                   // Move to the next element
                   currentElementIndex++;
                   currentCharIndex = 0;
                   
                   // Mark the current element as completed
                   currentItem.element.classList.remove('current');
                   currentItem.element.classList.add('completed');
                   currentItem.completed = true;
                   
                   // Update the corresponding element in totalTypeableElements
                   const globalIndex = getPageStartIndex(currentPageIndex) + currentElementIndex - 1;
                   if (globalIndex >= 0 && globalIndex < totalTypeableElements.length) {
                       totalTypeableElements[globalIndex].completed = true;
                   }
                   
                   // Update stats
                   updateStats();
                   
                   // Highlight the next element
                   highlightCurrentElement();
                   return;
               }
               
               // Get the expected character and the typed character
               const expectedChar = text[currentCharIndex];
               const typedChar = e.key;
               
               // Get the character spans
               const charSpans = currentItem.element.querySelectorAll('.text-char');
               const currentSpan = charSpans[currentCharIndex];
               
               totalTyped++;
               
               if (typedChar === expectedChar) {
                   // Correct character
                   currentSpan.classList.add('correct');
                   currentCharIndex++;
                   correctlyTyped++;
               } else {
                   // Incorrect character
                   currentSpan.classList.add('incorrect');
                   errors++;
                   currentCharIndex++;
               }
               
               // Update display
               highlightCurrentChar(currentItem.element);
               
               // Check if we've reached the end of the current element
               if (currentCharIndex >= text.length) {
                   // Move to the next element
                   setTimeout(() => {
                       currentElementIndex++;
                       currentCharIndex = 0;
                       
                       // Mark the current element as completed
                       currentItem.element.classList.remove('current');
                       currentItem.element.classList.add('completed');
                       currentItem.completed = true;
                       
                       // Update the corresponding element in totalTypeableElements
                       const globalIndex = getPageStartIndex(currentPageIndex) + currentElementIndex - 1;
                       if (globalIndex >= 0 && globalIndex < totalTypeableElements.length) {
                           totalTypeableElements[globalIndex].completed = true;
                       }
                       
                       // Update stats
                       updateStats();
                       
                       // Highlight the next element
                       highlightCurrentElement();
                       
                       // Auto-save progress every time we complete an element
                       if (currentElementIndex % 5 === 0) { // Save every 5 elements
                           saveProgress(true); // Silent save
                       }
                   }, 100);
               }
               
               // Update stats
               updateStats();
           }
           
           // Update the statistics
           function updateStats() {
               if (!startTime) return;
               
               const currentTime = new Date();
               const elapsedTimeInSeconds = (currentTime - startTime) / 1000;
               const elapsedTimeInMinutes = elapsedTimeInSeconds / 60;
               
               // Calculate total characters in all typeable elements
               let totalChars = 0;
               totalTypeableElements.forEach(item => {
                   totalChars += item.text.length;
               });
               
               // Calculate WPM based only on correctly typed characters
               const wordsTyped = correctlyTyped / 5; // Assuming average word is 5 characters
               const wpm = Math.round(wordsTyped / elapsedTimeInMinutes) || 0;
               
               // Calculate accuracy
               const accuracy = totalTyped > 0 ? Math.round(((totalTyped - errors) / totalTyped) * 100) : 100;
               
               // Calculate overall progress
               let completedChars = 0;
               let totalCharsInDocument = 0;
               
               // Count completed characters based on totalTypeableElements
               totalTypeableElements.forEach(item => {
                   totalCharsInDocument += item.text.length;
                   
                   if (item.completed) {
                       completedChars += item.text.length;
                   }
               });
               
               // Add characters typed in current element
               if (currentElementIndex < pageTypeableElements.length) {
                   completedChars += currentCharIndex;
               }
               
               const progress = Math.round((completedChars / totalCharsInDocument) * 100) || 0;
               
               // Update UI
               wpmValue.textContent = wpm;
               accuracyValue.textContent = `${accuracy}%`;
               progressValue.textContent = `${progress}%`;
           }
           
           // Show the completion modal
           function showCompletionModal() {
               // Calculate final stats
               const endTime = new Date();
               const elapsedTimeInSeconds = Math.round((endTime - startTime) / 1000);
               const minutes = Math.floor(elapsedTimeInSeconds / 60);
               const seconds = elapsedTimeInSeconds % 60;
               
               // Calculate total characters in all typeable elements
               let totalChars = 0;
               totalTypeableElements.forEach(item => {
                   totalChars += item.text.length;
               });
               
               // Calculate WPM based on correctly typed characters
               const elapsedTimeInMinutes = elapsedTimeInSeconds / 60;
               const wordsTyped = correctlyTyped / 5; // Assuming average word is 5 characters
               const wpm = Math.round(wordsTyped / elapsedTimeInMinutes) || 0;
               
               // Calculate accuracy
               const accuracy = totalTyped > 0 ? Math.round(((totalTyped - errors) / totalTyped) * 100) : 100;
               
               // Update the modal
               finalWpm.textContent = wpm;
               finalAccuracy.textContent = `${accuracy}%`;
               finalTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
               
               // Show the modal
               completionModal.style.display = 'flex';
               
               // Clear saved progress
               localStorage.removeItem(`typecraft-session-${currentFileName}`);
               checkSavedSessions();
           }
        // Reset the typing session
           function resetTypingSession() {
               // Reset state
               currentElementIndex = 0;
               currentCharIndex = 0;
               startTime = null;
               errors = 0;
               totalTyped = 0;
               correctlyTyped = 0;
               isTyping = false;
               
               // Reset all document pages
               documentPages.forEach((page, pageIndex) => {
                   // Reset text document elements
                   page.querySelectorAll('.typeable-wrapper').forEach(wrapper => {
                       wrapper.classList.remove('current', 'completed');
                       
                       // Reset character spans
                       wrapper.querySelectorAll('.text-char').forEach(charSpan => {
                           charSpan.classList.remove('current', 'correct', 'incorrect');
                       });
                   });
               });
               
               // Reset completed state for all totalTypeableElements
               totalTypeableElements.forEach(item => {
                   item.completed = false;
               });
               
               // Return to the first page
               navigateToPage(0);
               
               // Reset focus
               documentViewport.focus();
               
               // Reset stats
               wpmValue.textContent = '0';
               accuracyValue.textContent = '0%';
               progressValue.textContent = '0%';
           }
           
           // Save progress to localStorage
           function saveProgress(silent = false) {
               if (!currentFileName) return;
               
               // Calculate progress percentage
               let completedChars = 0;
               let totalCharsInDocument = 0;
               
               // Count completed characters based on totalTypeableElements
               totalTypeableElements.forEach(item => {
                   totalCharsInDocument += item.text.length;
                   
                   if (item.completed) {
                       completedChars += item.text.length;
                   }
               });
               
               // Add characters typed in current element
               if (currentElementIndex < pageTypeableElements.length) {
                   completedChars += currentCharIndex;
               }
               
               const progress = completedChars / totalCharsInDocument;
               
               // Create session data
               const sessionData = {
                   fileName: currentFileName,
                   fileType: fileType,
                   fileContent: fileContent,
                   currentPageIndex: currentPageIndex,
                   currentElementIndex: currentElementIndex,
                   currentCharIndex: currentCharIndex,
                   completedElements: totalTypeableElements.map(item => item.completed),
                   progress: progress,
                   timestamp: new Date().toISOString()
               };
               
               // Save to localStorage
               localStorage.setItem(`typecraft-session-${currentFileName}`, JSON.stringify(sessionData));
               
               // Show save indicator if not silent
               if (!silent) {
                   saveIndicator.classList.add('visible');
                   setTimeout(() => {
                       saveIndicator.classList.remove('visible');
                   }, 2000);
               }
           }
           
           // Get all saved sessions
           function getSavedSessions() {
               const sessions = [];
               
               for (let i = 0; i < localStorage.length; i++) {
                   const key = localStorage.key(i);
                   if (key.startsWith('typecraft-session-')) {
                       try {
                           const session = JSON.parse(localStorage.getItem(key));
                           sessions.push(session);
                       } catch (e) {
                           console.error('Error parsing saved session:', e);
                       }
                   }
               }
               
               // Sort by timestamp (most recent first)
               return sessions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
           }
           
           // Delete a saved session
           function deleteSavedSession(fileName) {
               localStorage.removeItem(`typecraft-session-${fileName}`);
           }
           
           // Flag to track if we're loading a saved session
           let isLoadingSavedSession = false;
           
           // Load a saved session
           function loadSavedSession(fileName) {
               const sessionKey = `typecraft-session-${fileName}`;
               const sessionData = JSON.parse(localStorage.getItem(sessionKey));
               
               if (!sessionData) return;
               
               // Set the current file name
               currentFileName = sessionData.fileName;
               documentTitle.textContent = currentFileName;
               
               // Set loading flag
               isLoadingSavedSession = true;
               
               // Show loading indicator
               loadingIndicator.style.display = 'flex';
               loadingText.textContent = 'Loading saved session...';
               
               // Process file content based on file type
               if (sessionData.fileType === 'application/pdf' || currentFileName.toLowerCase().endsWith('.pdf')) {
                   // Create a blob from the stored file content
                   const blob = new Blob([new Uint8Array(Object.values(sessionData.fileContent))], { type: 'application/pdf' });
                   const file = new File([blob], currentFileName, { type: 'application/pdf' });
                   
                   // Process the PDF
                   processPdfDocument(file).then(() => {
                       // Restore session state
                       setTimeout(() => {
                           restoreTypingProgress(sessionData);
                       }, 1000);
                   });
               } else if (sessionData.fileType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || 
                        currentFileName.toLowerCase().endsWith('.docx')) {
                   // Create a blob from the stored file content
                   const blob = new Blob([new Uint8Array(Object.values(sessionData.fileContent))], 
                       { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                   const file = new File([blob], currentFileName, 
                       { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                   
                   // Process the Word document
                   processWordDocument(file);
                   
                   // Use a timeout to ensure the document is processed before restoring progress
                   setTimeout(() => {
                       restoreTypingProgress(sessionData);
                   }, 1000);
               } else {
                   // For text-based files
                   const blob = new Blob([sessionData.fileContent], { type: 'text/plain' });
                   const file = new File([blob], currentFileName, { type: 'text/plain' });
                   
                   // Process the text document
                   processTextDocument(file);
                   
                   // Use a timeout to ensure the document is processed before restoring progress
                   setTimeout(() => {
                       restoreTypingProgress(sessionData);
                   }, 1000);
               }
           }
           
           // Restore typing progress after loading a saved session
           function restoreTypingProgress(sessionData) {
               // Navigate to the saved page
               if (sessionData.currentPageIndex < documentPages.length) {
                   navigateToPage(sessionData.currentPageIndex);
               }
               
               // Restore completed elements
               if (sessionData.completedElements && sessionData.completedElements.length > 0) {
                   // Update completedElements in totalTypeableElements
                   for (let i = 0; i < Math.min(sessionData.completedElements.length, totalTypeableElements.length); i++) {
                       totalTypeableElements[i].completed = sessionData.completedElements[i];
                       
                       if (sessionData.completedElements[i]) {
                           // Find the element in the DOM and mark it as completed
                           const element = totalTypeableElements[i].element;
                           element.classList.add('completed');
                           
                           // Mark all characters as correct
                           const charSpans = element.querySelectorAll('.text-char');
                           charSpans.forEach(span => {
                               span.classList.add('correct');
                           });
                       }
                   }
               } else {
                   // Fallback for older saved sessions without completedElements
                   
                   // Mark completed elements on previous pages
                   for (let i = 0; i < sessionData.currentPageIndex; i++) {
                       const pageElements = documentPages[i].querySelectorAll('.typeable-wrapper');
                       pageElements.forEach(element => {
                           element.classList.add('completed');
                           
                           // Mark all characters as correct
                           const charSpans = element.querySelectorAll('.text-char');
                           charSpans.forEach(span => {
                               span.classList.add('correct');
                           });
                       });
                   }
                   
                   // Mark completed elements on current page
                   const pageElements = Array.from(documentPages[sessionData.currentPageIndex].querySelectorAll('.typeable-wrapper'));
                   for (let i = 0; i < sessionData.currentElementIndex; i++) {
                       if (i < pageElements.length) {
                           pageElements[i].classList.add('completed');
                           
                           // Mark all characters as correct
                           const charSpans = pageElements[i].querySelectorAll('.text-char');
                           charSpans.forEach(span => {
                               span.classList.add('correct');
                           });
                       }
                   }
               }
               
               // Restore position within current element
               if (sessionData.currentElementIndex < pageTypeableElements.length) {
                   currentElementIndex = sessionData.currentElementIndex;
                   currentCharIndex = sessionData.currentCharIndex;
                   
                   // Mark current element as current
                   const currentItem = pageTypeableElements[currentElementIndex];
                   if (currentItem) {
                       currentItem.element.classList.add('current');
                       
                       // Mark typed characters as correct
                       const charSpans = currentItem.element.querySelectorAll('.text-char');
                       for (let i = 0; i < currentCharIndex; i++) {
                           if (i < charSpans.length) {
                               charSpans[i].classList.add('correct');
                           }
                       }
                   }
               }
               
               // Highlight current position
               highlightCurrentElement();
               
               // Hide loading indicator
               loadingIndicator.style.display = 'none';
               welcomeScreen.style.display = 'none';
               typingView.style.display = 'block';
               
               // Focus on the document for typing
               documentViewport.focus();
               
               // Update stats
               updateStats();
           }
           
           // Function to create a demo document with the learning article
           function createLearningArticleDocument() {
               // Create a text blob with the learning article content
               const articleText = `# Learning Through Typing: How TypeCraft Enhances Knowledge Retention

## The Science Behind Active Learning

When we read passively, our brains often go into "cruise control" mode, which can limit how much information we truly absorb and retain. TypeCraft transforms this passive experience into an active one by engaging your motor skills alongside your cognitive processes. This multi-sensory approach creates stronger neural pathways and enhances memory formation.

Research in cognitive psychology has consistently shown that active engagement with material leads to better learning outcomes than passive consumption. By physically typing each character of your study material, you:

- Slow down your reading pace to a more deliberate level
- Process information through multiple channels (visual, tactile, cognitive)
- Create additional memory cues through physical movement
- Force yourself to pay attention to every word, reducing mind-wandering

## Effective Learning Strategies with TypeCraft

### 1. The Focused First Pass

For your initial engagement with complex material, use TypeCraft to complete a "focused first pass." This technique involves typing through the material with full attention, deliberately slowing your consumption rate to match your typing speed. This enforced pacing helps prevent the common mistake of rushing through difficult concepts before they're fully understood.

### 2. Selective Emphasis

When reviewing material you've previously studied, use TypeCraft strategically:
- Type only the key paragraphs that contain core concepts
- Type definitions and critical formulas verbatim to reinforce precise terminology
- Skip sections you've already mastered to focus your typing energy on challenging areas

### 3. Synthesis and Note-Taking

After typing through source material, create a second document with your own synthesized notes:
- Summarize key concepts in your own words
- Create connections between different sections or topics
- Formulate questions about the material to explore later
- Type these personalized notes to further reinforce learning

## Cognitive Benefits of the TypeCraft Method

### Enhanced Focus and Attention

The act of typing creates a continuous feedback loop—your brain must maintain focus to accurately reproduce each character. Unlike passive reading where attention can drift unnoticed, typing immediately reveals lapses in concentration through errors, helping you develop stronger focus over time.

### Improved Comprehension

When you type content, you engage with it at a deeper level than when simply reading. This deliberate processing improves understanding, especially for complex materials such as:
- Technical documentation
- Research papers
- Programming concepts
- Mathematical explanations
- Legal documents

### Stronger Memory Formation

TypeCraft leverages the production effect—the phenomenon where information that is actively produced (by typing) is better remembered than information that is merely read. Each keystroke serves as a mini-commitment to the material, creating additional memory hooks.

## Practical Applications

### Academic Learning

Students can use TypeCraft to:
- Type through lecture notes to reinforce classroom learning
- Process textbook chapters for better retention
- Prepare for exams by typing through summary materials
- Create study guides by typing key concepts

### Professional Development

Professionals can leverage TypeCraft to:
- Learn new industry standards or regulations
- Master technical documentation
- Absorb business reports and analyses
- Internalize presentation materials

### Language Learning

Language learners benefit from TypeCraft by:
- Reinforcing vocabulary through muscle memory
- Developing familiarity with grammar structures
- Practicing spelling in non-native languages
- Typing through example dialogues and phrases

## Getting Started: A Simple Workflow

1. Prepare your material - Upload a document containing information you want to learn
2. Set a realistic goal - Aim to type through a manageable section in each session
3. Type with intention - Focus on understanding, not just reproduction of text
4. Review your errors - Notice patterns in your mistakes that might indicate attention lapses
5. Create follow-up notes - After typing through source material, create your own summary document

## Conclusion

TypeCraft transforms the fundamentally passive activity of reading into an active learning experience. By engaging your brain and body simultaneously, you create multiple pathways for information retention and deeper understanding. Whether you're a student tackling complex subjects, a professional mastering new skills, or a lifelong learner expanding your knowledge, the simple act of typing what you read can dramatically enhance how much you learn and retain.

Start your TypeCraft journey today, and experience the difference that active, engaged learning can make in your educational and professional pursuits.`;

               // Create a blob from the text
               const blob = new Blob([articleText], { type: 'text/markdown' });
               
               // Create a file object
               const file = new File([blob], "TypeCraft_Learning_Guide.md", { type: 'text/markdown' });
               
               // Process the file
               currentFile = file;
               currentFileName = file.name;
               processMarkdownDocument(file);
           }
           
           // Add event listener for the demo button
           tryTypeBtn.addEventListener('click', () => {
               createLearningArticleDocument();
               learningView.style.display = 'none';
           });
       });
   </script>
</body>
</html>
